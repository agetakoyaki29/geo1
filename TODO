
* remove Delta.eq0(d: Double)
delta usecase

* make test data

* implemente dir2

* rename WithDelta func
instead of Strict or Ideal

* Double epsilon

* is* naming
dir isOn pt
dir isIntersect line

* rename package
line => line2
 => fegure2

* case Double.NaN -> d if d.isNaN

* PartialFunction validation
type =?>[A,B] = PartialFunction[A,B]
val NonZero: Double =?> Any = { case d if d == 0 => throw new IllegalArgumentException("Not Zero") }
NonZero orElse NonInf orElse { case d => super.*(d) }
NonZero orElse NonInf andThen super.*
パッケージオブジェクト

* Transform.localize

* Transform.update func
obj(pos) = np

* what happen call intersect when each is same

* check isChomp

* super case
def scase[A](any: A) = any.asInstanceOf[A]
obj.super[A]


---

* 誤差の取り扱い

* asInstance is dynamic
戻り値同型の法則をどうやって実装する？
